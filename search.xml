<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Cookie、Session、LocalStorage、Cache-Control相关内容]]></title>
    <url>%2FTongWenQian%2F2019%2F07%2F03%2F%E5%85%B3%E4%BA%8ECookie%E3%80%81Session%E3%80%81Localstorage%E3%80%81Cache-Control%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[关于 Cookie、Session、LocalStorage、Cache-ControlCookie 存在的问题用户可以随意篡改 Cookie Session 与 Cookie 的关系一般来说，Session 基于 Cookie 来实现。因为需要将 SessionID（随机数）通过 Cookie 发给客户端。 Cookie 服务器通过 Set-Cookie 头给客户端一串字符串 客户端每次访问相同域名的网页时，必须带上这段字符串 客户端要在一段时间内保存这个Cookie Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间大小大概在 4kb 以内前端永远不要读，写 cookie!!!! Session（不翻译） 将 SessionID（随机数）通过 Cookie 发给客户端 客户端访问服务器时，服务器读取 SessionID 服务器有一块内存（哈希表）保存了所有 session 通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email 这块内存（哈希表）就是服务器上的所有 session session 的缺点就是占内存， 而 cookie 不占内存 LocalStoragehtml5 提供的 API。 存值方法如下图注意：上述方法只能存储 string。图片2中貌似存入了函数，实际上存的是 string，只不过是将函数转化成了 string。假如存入了 Object 对象。如下图：结果存储的是：(因为 任何对象.toString() 都会变成[Object Object])解决办法如下：问题： cookie 和 localStorage 的区别是什么？答： cookie 在每次请求的时候都会带给服务器，但 HTTP 不会带上 LocalStorage 的值。 cookie 的最大储存量为 4kb。localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）。 取值方法如下图 清空 localStorage.clear() localStorage 用法 对于 windows 用户来说， localStorage 存在 C 盘的文件里(持久化存储)，而不是存在页面中。 localStorage 最典型的应用，记录下有没有提示用户。假设一个网站改版了，弹出窗口提示用户网站改版.代码如下： LocalStorage 跟 HTTP 无关 HTTP 不会带上 LocalStorage 的值 只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格） 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样） 举例如下(122M)： 结果出现如下错误： 常用场景：记录有没有提示过用户（没有用的信息，不能记录密码） LocalStorage 永久有效，除非用户清理缓存 举例：Chrome 浏览器按住 ctrl+shift+delete,勾选”cookie 及其他网站数据（其中’其他网站数据’中就包含localStorage） sessionStorage（会话存储）1、2、3、4 同上 SessionStorage 在用户关闭页面（会话结束）后就失效。 sessionStorage 的使用方法 使用法法如下：注意：sessionStorage 与 localstorage 的区别在于：localStorage 不会自动过期，但是 sessionStorage 会自动过期（关闭页面的时候就会过期清空）。 HTTP 缓存Cache-Control(Web 性能优化) 举例如下：“Cache-Control:max-age=30”表示 30s 内不要再次请求。过程图如下： 如何更新缓存如果所有的东西都缓存一天或者xx秒，那么很难获得最新的网页。解决办法：首页（index.html)不要设置缓存。假设有一个js设置的 10 年不更新,已知只有相同的 URL 才会用之前的缓存，那么只要让 url 不同即可（比如添加参数），如下图： ExpireExpire 类似 Cache-Control，但是它是设置时间点过期，而 Cache-Control 是设置的多长时间过期。如果用户的本地时间异常（假设设置的时间点在十年之后），那么则有可能永远过期。 ETag首先讲讲 md5 ，md5 是摘要算法（把一个文件变成字符串，如果文件有任何地方的改动，那么其对应的 md5 差异会很大）。md5 的一个很大的特征就是如果内容的差异越小，那么算出的结果差异就越大。 Last-Modified在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：1Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：1If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT 如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求 缓存与 304 的区别 缓存没有请求。 304 有请求，有响应，但是响应没有第四部分。 测试 Cookie 和 Session 的区别答：Cookie 保存在客户端，每次都随请求发送给 ServerSession 保存在 Server 的内存里，其 Session ID 是通过 Cookie 发送给客户端的 Cookie 和 LocalStorage 的区别答：1) LocalStorage 不会随 HTTP 发给 Server2) LocalStorage 的大小限制比 Cookie 大多了 LocalStorage 和 SessionStorage 的区别答：localStorage 不会自动过期，但是 sessionStorage 会自动过期（关闭页面的时候就会过期清空） Cookie 如何设置过期时间？如何删除 Cookie？答：前端设置document.cookie(name=alias; expires=${过期时间};)2.服务器设置 node示例：response.setHeader(“Set-Cookie’,‘name=alias; expires=${过期时间}’)删除：1.前端删除document.cookie(name=alias; expires=${当前时间的前一天};)2.noderesponse.setHeader(“Set-Cookie’,‘name=alias; expires=${当前时间的前一天}’) Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？答：Cache-Control 直接不发请求。而 ETag 要发请求才行。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>Localstorage</tag>
        <tag>Cache-Control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高级基础知识考试]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F21%2FJS%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[JS高级基础知识考试1 填空123456789101112131415161718var object = &#123;&#125;object.__proto__ === ????填空1???? // 为 truevar fn = function()&#123;&#125;fn.__proto__ === ????填空2???? // 为 truefn.__proto__.__proto__ === ????填空3???? // 为 truevar array = []array.__proto__ === ????填空4???? // 为 truearray.__proto__.__proto__ === ????填空5???? // 为 trueFunction.__proto__ === ????填空6???? // 为 trueArray.__proto__ === ????填空7???? // 为 trueObject.__proto__ === ????填空8???? // 为 truetrue.__proto__ === ????填空9???? // 为 trueFunction.prototype.__proto__ === ????填空10???? // 为 true 答：123456789101112131415161718var object = &#123;&#125;object.__proto__ === Object.prototype // 为 truevar fn = function()&#123;&#125;fn.__proto__ === Function.prototype // 为 truefn.__proto__.__proto__ === Object.prototype // 为 truevar array = []array.__proto__ === Array.prototype // 为 truearray.__proto__.__proto__ ===Object.prototype // 为 trueFunction.__proto__ ===Function.prototype// 为 trueArray.__proto__ === Function.prototype // 为 trueObject.__proto__ === Function.prototype // 为 truetrue.__proto__ === Boolean.prototype // 为 trueFunction.prototype.__proto__ === Object.prototype // 为 true 21234function Fn()&#123; console.log(this)&#125;new Fn() new Fn() 会执行 Fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？答：this 自身没有属性（只有一个隐藏的 proto属性）this 的原型是fn.prototype，只有一个属性constructor，且 constructor === fn（另外还有一个隐藏属性proto，指向 Object.prototype） 3JSON 和 JavaScript 是什么关系？JSON 和 JavaScript 的区别有哪些？答：关系：JSON 是一门抄袭/借鉴 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法） 区别：JSON 不支持函数、undefined、变量、引用、单引号字符串、对象的key不支持单引号也不支持不加引号、没有内置的 Date、Math、RegExp 等。而 JavaScript 全都支持。 4前端 MVC 是什么？（10分）请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。（10分）答：MVC 是什么MVC 是一种设计模式（或者软件架构），把系统分为三层：Model数据、View视图和Controller控制器。Model 数据管理，包括数据逻辑、数据请求、数据存储等功能。前端 Model 主要负责 AJAX 请求或者 LocalStorage 存储View 负责用户界面，前端 View 主要负责 HTML 渲染。Controller 负责处理 View 的事件，并更新 Model；也负责监听 Model 的变化，并更新 View，Controller 控制其他的所有流程。 代码说明12345678910111213141516171819202122232425var model = &#123; data: null, init()&#123;&#125; fetch()&#123;&#125; save()&#123;&#125; update()&#123;&#125; delete()&#123;&#125;&#125;view = &#123; init() &#123;&#125; template: &apos;&lt;h1&gt;hi&lt;/h1&apos;&gt;&#125;controller = &#123; view: null, model: null, init(view, model)&#123; this.view = view this.model = model this.bindEvents() &#125; render()&#123; this.view.querySelector(&apos;name&apos;).innerText = this.model.data.name &#125;, bindEvents()&#123;&#125;&#125; 5在 ES5 中如何用函数模拟一个类？（10分）答：ES 5 没有 class 关键字，所以只能使用函数来模拟类。123456function Human(name)&#123; this.name = name&#125;Human.prototype.run = function()&#123;&#125;var person = new Human(&apos;frank&apos;) 上面代码就是一个最简单的类，Human 构造函数创建出来的对象自身有 name 属性，其原型上面有一个 run 属性。 6用过 Promise 吗？举例说明。如果要你创建一个返回 Promise 对象的函数，你会怎么写？举例说明。答：用过 Promise，比如 jQuery 或者 axios 的 AJAX 功能，都返回的是 Promise 对象。 $.ajax({url:’/xxx’, method:’get’}).then(success1, error1).then(success2, error2)如果我自己创建 Promise 对象，我会这么写12345678function asyncMethod()&#123; return new Promise(function (resolve, reject)&#123; setTimeout(function()&#123; 成功则调用 resolve 失败则调用 reject &#125;,3000) &#125;)&#125;]]></content>
      <categories>
        <category>每日一练</category>
      </categories>
      <tags>
        <tag>JS测试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F07%2FAJAX%2F</url>
    <content type="text"><![CDATA[如何发请求？用 form 可以发请求，但是会刷新页面或新开页面用 a 可以发 get 请求，但是也会刷新页面或新开页面用 img 可以发 get 请求，但是只能以图片的形式展示用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示用 script 可以发 get 请求，但是只能以脚本的形式运行有没有什么方式可以实现 get、post、put、delete 请求都行 想以什么形式展示就以什么形式展示 微软的突破IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。随后 Mozilla、 Safari、 Opera 也跟进（抄袭）了，取名 XMLHttpRequest，并被纳入 W3C 规范 AJAXJesse James Garrett 讲如下技术取名叫做 AJAX：异步的 JavaScript 和 XML 使用 XMLHttpRequest 发请求 服务器返回 XML 格式的字符串 JS 解析 XML，并更新局部页面 如何使用 XMLHttpRequest12345678910111213141516171819202122232425262728293031323334353637383940414243444546myButton.addEventListener(&apos;click&apos;, (e)=&gt;&#123; let request = new XMLHttpRequest() request.open(&apos;get&apos;, &apos;/xxx&apos;) // 配置request request.send() request.onreadystatechange = ()=&gt;&#123; if(request.readyState === 4)&#123; console.log(&apos;请求响应都完毕了&apos;) console.log(request.status) if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123; console.log(&apos;说明请求成功&apos;) console.log(typeof request.responseText) console.log(request.responseText) let string = request.responseText // 把符合 JSON 语法的字符串 // 转换成 JS 对应的值 let object = window.JSON.parse(string) // JSON.parse 是浏览器提供的 console.log(typeof object) console.log(object) console.log(&apos;object.note&apos;) console.log(object.note) &#125;else if(request.status &gt;= 400)&#123; console.log(&apos;说明请求失败&apos;) &#125; &#125; &#125;&#125;)// 后端代码 &#125;else if(path===&apos;/xxx&apos;)&#123; response.statusCode = 200 response.setHeader(&apos;Content-Type&apos;, &apos;text/json;charset=utf-8&apos;) response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://frank.com:8001&apos;) response.write(` &#123; &quot;note&quot;:&#123; &quot;to&quot;: &quot;小谷&quot;, &quot;from&quot;: &quot;方方&quot;, &quot;heading&quot;: &quot;打招呼&quot;, &quot;content&quot;: &quot;hi&quot; &#125; &#125; `) response.end() JSON —— 一门新语言http://json.org/ 同源策略只有 协议+端口+域名 一模一样才允许发 AJAX 请求 http://baidu.com 可以向 http://www.baidu.com 发 AJAX 请求吗 nohttp://baidu.com:80 可以向 http://baidu.com:81 发 AJAX 请求吗 no浏览器必须保证只有 协议+端口+域名 一模一样才允许发 AJAX 请求CORS 可以告诉浏览器，我俩一家的，别阻止他 突破同源策略 === 跨域 Cross-Origin Resource SharingC O源 R S 问题：为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？答： 因为原页面用 form 提交到另一个域名之后，原页面的脚本无法获取页面中的内容。所以浏览器认为这是安全的。 而 ajax 可以读取响应内容的。因此浏览器不允许你这么做。 如果细心可以发现，其实请求已经发送出去了，你只是拿不到响应而已。 所以浏览器这个策略的本质是：一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容，但浏览器并不阻止你向另一个域名发送请求。 CORS 跨域 (跨站资源共享)response.setHeader(‘Access-Control-Allow-Origin’, ‘http://frank.com:8001&#39;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPSON]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F07%2FJPSON%2F</url>
    <content type="text"><![CDATA[数据库是什么鬼 文件系统是一种数据库 MySQL 是一种数据库只要能长久地存数据，就是数据库 局部刷新怎么做？思路：不返回 HTML，返回 JS 方案一用图片造 get 请求12345678910button.addEventListener(&apos;click&apos;, (e)=&gt;&#123; let image = document.createElement(&apos;img&apos;) image.src = &apos;/pay&apos; image.onload = function()&#123; // 状态码是 200~299 则表示成功 alert(&apos;成功&apos;) &#125; image.onerror = function()&#123; // 状态码大于等于 400 则表示失败 alert(&apos;失败&apos;) &#125;&#125;) 方案二用 script 造 get 请求1234567891011button.addEventListener(&apos;click&apos;, (e)=&gt;&#123; let script = document.createElement(&apos;script&apos;) script.src = &apos;/pay&apos; document.body.appendChild(script) script.onload = function(e)&#123; // 状态码是 200~299 则表示成功 e.currentTarget.remove() &#125; script.onerror = function(e)&#123; // 状态码大于等于 400 则表示失败 e.currentTarget.remove() &#125;&#125;) 123456789//后端代码if (path === &apos;/pay&apos;)&#123; let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;) amount -= 1 fs.writeFileSync(&apos;./db&apos;, amount) response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;) response.write(&apos;amount.innerText = &apos; + amount) response.end()&#125; 这种技术叫做 SRJ - Server Rendered JavaScript 方案三JSONP请求方：frank.com 的前端程序员（浏览器）响应方：jack.com 的后端程序员（服务器） 请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 响应方根据查询参数callbackName，构造形如 yyy.call(undefined, ‘你要的数据’) yyy(‘你要的数据’)这样的响应 浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’) 那么请求方就知道了他要的数据 这就是 JSONP约定： callbackName -&gt; callback yyy -&gt; 随机数 frank12312312312321325() 1234567891011$.ajax(&#123; url: &quot;http://jack.com:8002/pay&quot;, dataType: &quot;jsonp&quot;, success: function( response ) &#123; if(response === &apos;success&apos;)&#123; amount.innerText = amount.innerText - 1 &#125; &#125; &#125;) $.jsonp() 代码如下：1234567891011121314151617button.addEventListener(&apos;click&apos;, (e)=&gt;&#123; let script = document.createElement(&apos;script&apos;) let functionName = &apos;frank&apos;+ parseInt(Math.random()*10000000 ,10) window[functionName] = function()&#123; // 每次请求之前搞出一个随机的函数 amount.innerText = amount.innerText - 0 - 1 &#125; script.src = &apos;/pay?callback=&apos; + functionName document.body.appendChild(script) script.onload = function(e)&#123; // 状态码是 200~299 则表示成功 e.currentTarget.remove() delete window[functionName] // 请求完了就干掉这个随机函数 &#125; script.onerror = function(e)&#123; // 状态码大于等于 400 则表示失败 e.currentTarget.remove() delete window[functionName] // 请求完了就干掉这个随机函数 &#125;&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//后端代码...var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)// var port = process.argv[2]var port = process.env.PORT || 8888;if(!port)&#123; console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;) process.exit(1)&#125;var server = http.createServer(function(request, response)&#123; var parsedUrl = url.parse(request.url, true) var pathWithQuery = request.url var queryString = &apos;&apos; if(pathWithQuery.indexOf(&apos;?&apos;) &gt;= 0)&#123; queryString = pathWithQuery.substring(pathWithQuery.indexOf(&apos;?&apos;)) &#125; var path = parsedUrl.pathname var query = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/console.log(path)console.log(query.callback)if (path === &apos;/pay&apos;)&#123; let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;) amount -= 1 fs.writeFileSync(&apos;./db&apos;, amount) let callbackName = query.callback response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;) response.write(` $&#123;callbackName&#125;.call(undefined, &quot;success&quot;) `) response.end()&#125; // console.log(&apos;方方说：含查询字符串的路径\n&apos; + pathWithQuery) // if(path === &apos;/path&apos;)&#123; // response.statusCode = 200 // response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) // response.write(&apos;哈哈哈&apos;) // response.end() // &#125;else&#123; // response.statusCode = 404 // response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) // response.write(&apos;呜呜呜&apos;) // response.end() // &#125; /******** 代码结束，下面不要看 ************/&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port) 12345678910111213141516171819202122232425262728/**html**/&lt;body&gt; &lt;p style=&apos;margin:30px 0&apos;&gt;您的账户余额是&lt;span id=&apos;amount&apos;&gt;100&lt;/span&gt; &lt;/p&gt; &lt;button id=&apos;button&apos;&gt;打钱&lt;/button&gt; &lt;script&gt; $(button).on(&apos;click&apos;,function()&#123; $(function() &#123; $.ajax(&#123;//实际不是ajax，还是JSONP url: &apos;http://jack.com:8002/pay&apos;, //jack.com需要设置hosts(127.0.0.1 jack.com) type: &apos;GET&apos;, dataType: &apos;jsonp&apos;, jsonp: &apos;callback&apos;, jsonpCallback: &apos;jsonpCallback&apos;, success: function(data) &#123; console.log(data) if(data===&apos;success&apos;)&#123; amount.innerText=amount.innerText-1 &#125; &#125; &#125;); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; nodejs-test代码：https://github.com/TongWenQian/nodejs-test]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>= JPSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解DOM事件小动画]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F05%2F%E7%90%86%E8%A7%A3DOM%E4%BA%8B%E4%BB%B6%E5%B0%8F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[代码如下： 123456789101112131415161718192021222324/**html**/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;//code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;red&quot;&gt; &lt;div class=&quot;blue&quot;&gt; &lt;div class=&quot;green&quot;&gt; &lt;div class=&quot;yellow&quot;&gt; &lt;div class=&quot;orange&quot;&gt; &lt;div class=&quot;purple&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334/**css**/*&#123;margin:0;padding:0;box-sizing:border-box;&#125;.red.active &#123; background: red;&#125;.blue.active &#123; background: blue;&#125;.green.active &#123; background: green;&#125;.yellow.active &#123; background: yellow;&#125;.orange.active &#123; background: orange;&#125;.purple.active &#123; background: purple;&#125;div &#123; border: 1px solid black; padding: 10px; transition: all 0.5s; display: flex; flex:1; border-radius: 50%; background: white;&#125;.red&#123; width: 100vw; height: 100vw;&#125; 123456789101112131415161718192021/**js**/let divs = $(&apos;div&apos;).get()let n = 0for (let i = 0; i &lt; divs.length; i++) &#123; divs[i].addEventListener(&apos;click&apos;, () =&gt; &#123; setTimeout(() =&gt; &#123; divs[i].classList.add(&apos;active&apos;) &#125;, n * 500) n += 1 &#125;, true)&#125;for (let i = 0; i &lt; divs.length; i++) &#123; divs[i].addEventListener(&apos;click&apos;, () =&gt; &#123; setTimeout(() =&gt; &#123; divs[i].classList.remove(&apos;active&apos;) &#125;, n * 500) n += 1 &#125;)&#125; 预览链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>DOM 事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解DOM事件]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F05%2F%E7%90%86%E8%A7%A3DOM%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[如何做“点击其他地方关闭图层”方案1 代码如下：1234567891011121314151617/**html**/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;wrapper&quot; class=&quot;wrapper&quot;&gt; &lt;button id=&quot;clickMe&quot;&gt;点我&lt;/button&gt; &lt;div id=&quot;popover&quot; class=&quot;popover&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;浮层 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536/**css**/body&#123; border: 1px solid red;&#125;.wrapper&#123; position: relative; display: inline-block;&#125;.popover&#123; border: 1px solid red; position: absolute; left: 100%; top: 0; white-space: nowrap; padding: 10px; margin-left: 10px; background: white; display: none;&#125;.popover::before&#123; position: absolute; right: 100%; top: 5px; border: 10px solid transparent; border-right-color: red; content: &apos;&apos;;&#125;.popover::after&#123; position: absolute; right: 100%; top: 5px; border: 10px solid transparent; border-right-color: white; content: &apos;&apos;; margin-right: -1px;&#125; 1234567891011/**js**/clickMe.addEventListener(&apos;click&apos;, function(e)&#123; popover.style.display = &apos;block&apos;&#125;)wrapper.addEventListener(&apos;click&apos;, function(e)&#123; e.stopPropagation()&#125;)document.addEventListener(&apos;click&apos;, function()&#123; popover.style.display = &apos;none&apos;&#125;) 预览链接 方案2 预览链接 还是有bug，优化一下： http://js.jirengu.com/bimenewiji/3/edit?html,js,output 存在的 BUGBUG1http://js.jirengu.com/lagiyocuzu/3/edit BUG2http://js.jirengu.com/lagiyocuzu/4/edit]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>DOM 事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习-Linux命令行基础]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F05%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux 命令基础 什么是绝对路径？什么是相对路径？答：绝对路径是指文件或者目录在硬盘上真正的路径，例如 E:/user/1.png ，”/“开头，代表根目录。相对路径是指相对于当前的文件的路径。例如：./1.png 表示当前目录下的 1.png 图片。 如何查看当前位置的绝对路径？答： 在当前位置输入 pwd 命令。 如何查看系统的当前用户？答： 使用命令 whoami。 如何查看某个脚本命令的位置？（比如 node )答： 以 node 为例，使用命令 which node。 请问使用||命令输出的当前路径下的文件信息中，前面的 -rwxr-xr-x 是什么意思？答: 以从左到右顺序解释： 1) 开头的 - 表示：文件 2) r：可读 3) w：可写 4) x：表示可执行 5) 第一个 r-x：用户所在组的权限 6) 第二个 r-x：任意用户权限 **.*、./*、*.png 分别代表什么意思？答：代表如下： **.*：所有 xx.xx 格式的文件 ./*：表示当前目录下的所有文件和所有目录 *.png: 以 .png 结尾的文件 sudo 是什么意思？答： sudo 即 super user do ,它的意思是用超级管理员的权限执行（do）。 echo ‘aaa’ &gt; a.txt 与 echo ‘bbb’ &gt;&gt; b.txt 有什么区别？答： echo ‘aaa’ &gt; a.txt 表示创建一个 a.txt (如果a.txt不存在）文件，并在 a.txt 中添加 aaa 内容，若再次往 a.txt 添加内容，会覆盖之前的内容。而 echo ‘bbb’ &gt;&gt; b.txt 表示在 b.txt 追加内容，不会覆盖本来就有的文件内容。 cat 命令能做什么？答：可以进行如下使用： cat filename：显示该文件内容 cat &gt; filename：创建一个文件 cat filename1 filename2 &gt; filename：将两个文件合并成一个文件 chmod +777 a.sh 是什么意思？ chmod 是什么？+777 是什么意思？答： 表示任何人对 a.sh 都有读、写、运行三项权限。chmod 是目录或者文件权限设置的命令。由于读、写、运行三项权限可以用数字来表示，r=4,w=2,x=1，因此 777 表示 rwxrwxrwx ，即为该用户和其所在的组以及其他人都有最高的权限。]]></content>
      <categories>
        <category>前端</category>
        <category>每日练习</category>
      </categories>
      <tags>
        <tag>每日练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出ES6（四）：模板字符串（转载）]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F04%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAES6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[深入浅出ES6（四）：模板字符串反撇号（`）基础知识ES6引入了一种新型的字符串字面量语法，我们称之为模板字符串（template strings）。除了使用反撇号字符 ` 代替普通字符串的引号 ‘ 或 “ 外，它们看起来与普通字符串并无二致。在最简单的情况下，它们与普通字符串的表现一致：1context.fillText(`Ceci n&apos;est pas une chaîne.`, x, y); 但是我们并没有说：“原来只是被反撇号括起来的普通字符串啊”。模板字符串名之有理，它为JavaScript提供了简单的字符串插值功能，从此以后，你可以通过一种更加美观、更加方便的方式向字符串中插值了。模板字符串的使用方式成千上万，但是最让我会心一暖的是将其应用于毫不起眼的错误消息提示：123456function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( `用户 $&#123;user.name&#125; 未被授权执行 $&#123;action&#125; 操作。`); &#125;&#125; 在这个示例中，${user.name}和${action}被称为模板占位符，JavaScript将把user.name和action的值插入到最终生成的字符串中，例如：用户jorendorff未被授权打冰球。（这是真的，我还没有获得冰球许可证。）到目前为止，我们所了解到的仅仅是比 + 运算符更优雅的语法，下面是你可能期待的一些特性细节： 模板占位符中的代码可以是任意JavaScript表达式，所以函数调用、算数运算等这些都可以作为占位符使用，你甚至可以在一个模板字符串中嵌套另一个，我称之为模板套构 （template inception）。 如果这两个值都不是字符串，可以按照常规将其转换为字符串。例如：如果action是一个对象，将会调用它的.toString()方法将其转换为字符串值。 如果你需要在模板字符串中书写反撇号，你必须使用反斜杠将其转义：\`等价于”`”。 同样地，如果你需要在模板字符串中引入字符$和{。无论你要实现什么样的目标，你都需要用反斜杠转义每一个字符：\$和\{。与普通字符串不同的是，模板字符串可以多行书写：12345$(&quot;#warning&quot;).html(` &lt;h1&gt;小心！&gt;/h1&gt; &lt;p&gt;未经授权打冰球可能受罚 将近$&#123;maxPenalty&#125;分钟。&lt;/p&gt;`); 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 好啦，我说过要让你们轻松掌握模板字符串，从现在起难度会加大，你可以到此为止，去喝一杯咖啡，慢慢消化之前的知识。真的，及时回头不是一件令人感到羞愧的事情。Lopes Gonçalves曾经向我们证明过，船只不会被海妖碾压，也不会从地球的边缘坠落下去，他最终跨越了赤道，但是他有继续探索整个南半球么？并没有，他回家了，吃了一顿丰盛的午餐，你一定不排斥这样的感觉。 反撇号的未来当然，模板字符串也并非事事包揽： 它们不会为你自动转义特殊字符，为了避免跨站脚本漏洞，你应当像拼接普通字符串时做的那样对非置信数据进行特殊处理。 它们无法很好地与国际化库（可以帮助你面向不同用户提供不同的语言）相配合，模板字符串不会格式化特定语言的数字和日期，更别提同时使用不同语言的情况了。 它们不能替代模板引擎的地位，例如：Mustache、Nunjucks。模板字符串没有内建循环语法，所以你无法通过遍历数组来构建类似HTML中的表格，甚至它连条件语句都不支持。你当然可以使用模板套构（template inception）的方法实现，但在我看来这方法略显愚钝啊。 不过，ES6为JS开发者和库设计者提供了一个很好的衍生工具，你可以借助这一特性突破模板字符串的诸多限制，我们称之为标签模板（tagged templates）。 标签模板的语法非常简单，在模板字符串开始的反撇号前附加一个额外的标签即可。我们的第一个示例将添加一个SaferHTML标签，我们要用这个标签来解决上述的第一个限制：自动转义特殊字符。 请注意，ES6标准库不提供类似SaferHTML功能，我们将在下面自己来实现这个功能。12var message = SaferHTML`&lt;p&gt;$&#123;bonk.sender&#125; 向你示好。&lt;/p&gt;`; 这里用到的标签是一个标识符SaferHTML；也可以使用属性值作为标签，例如：SaferHTML.escape；还可以是一个方法调用，例如：SaferHTML.escape({unicodeControlCharacters: false})。精确地说，任何ES6的成员表达式（MemberExpression）或调用表达式（CallExpression）都可作为标签使用。可以看出，无标签模板字符串简化了简单字符串拼接，标签模板则完全简化了函数调用！上面的代码等效于：12var message = SaferHTML(templateData, bonk.sender); templateData是一个不可变数组，存储着模板所有的字符串部分，由JS引擎为我们创建。因为占位符将标签模板分割为两个字符串的部分，所以这个数组内含两个元素，形如Object.freeze([&quot;&lt;p&gt;&quot;, &quot; has sent you a bonk.&lt;/p&gt;&quot;]。 （事实上，templateData中还有一个属性，在这篇文章中我们不会用到，但是它是标签模板不可分割的一环：templateData.raw，它同样是一个数组，存储着标签模板中所有的字符串部分，如果我们查看源码将会发现，在这里是使用形如\n的转义序列分行，而在templateData中则为真正的新行，标准标签String.raw会用到这些原生字符串。） 如此一来，SaferHTML函数就可以有成千上万种方法来解析字符串和占位符。 在继续阅读以前，可能你苦苦思索到底用SaferHTML来做什么，然后着手尝试去实现它，归根结底，它只是一个函数，你可以在Firefox的开发者控制台里测试你的成果。 以下是一种可行的方案（在gist中查看）：123456789101112131415function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); // 转义占位符中的特殊字符。 s += arg.replace(/&amp;/g, &quot;&amp;&quot;) .replace(/&lt;/g, &quot;&lt;&quot;) .replace(/&lt;/g, &quot;&gt;&quot;); // 不转义模板中的特殊字符。 s += templateData[i]; &#125; return s;&#125; 通过这样的定义，标签模板SaferHTML&lt;p&gt;${bonk.sender} 向你示好。&lt;/p&gt; 可能扩展为字符串 “&lt;p&gt;ES6&lt;3er 向你示好。&lt;/p&gt;“。即使一个恶意命名的用户，例如“黑客Steve&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;”，向其他用户发送一条骚扰信息，无论如何这条信息都会被转义为普通字符串，其他用户不会受到潜在攻击的威胁。 （顺便一提，如果你感觉上述代码中在函数内部使用参数对象的方式令你感到枯燥乏味，不妨期待下一篇大作，ES6中的另一个新特性一定会让你眼前一亮！） 仅一个简单的示例不足以说明标签模板的灵活性，我们一起回顾下我们之前有关模板字符串限制的列表，看一下你还能做些什么不一样的事情。 模板字符串不会自动转义特殊字符。但是正如我们看到的那样，通过标签模板，你可以自己写一个标签函数来解决这个问题 事实上，你可以做的比那更好。 站在安全角度来说，我实现的SaferHTML函数相当脆弱，你需要通过多种不同的方式将HTML不同部分的特殊字符转义，SaferHTML就无法做到全部转义。但是稍加努力，你就可以写出一个更加智能的SaferHTML函数，它可以针对templateData中字符串中的HTML位进行解析，分析出哪一个占位符是纯HTML；哪一个是元素内部属性，需要转义’和”；哪一个是URL的query字符串，需要进行URL转义而非HTML转义，等等。智能SaferHTML函数可以将每个占位符都正确转义。 HTML的解析速度很慢，这种方法听起来是否略显牵强？幸运的是，当模板重新求值的时候标签模板的字符串部分是不改变的。SaferHTML可以缓存所有的解析结果，来加速后续的调用。（缓存可以按照ES6的另一个特性——WeakMap的形式进行存储，我们将在未来的文章中继续深入讨论。） 模板字符串没有内建的国际化特性，但是通过标签，我们可以添加这些功能。Jack Hsu的一篇博客文章展示了具体的实现过程。我谨在此处抛砖引玉：i18nHello ${name}, you have ${amount}:c(CAD) in your bank account.// =&gt; Hallo Bob, Sie haben 1.234,56 $CA auf Ihrem Bankkonto. 注意观察这个示例中的运行细节，name和amount都是JavaScript，进行正常插值处理，但是有一段与众不同的代码，:c(CAD)，Jack将它放入了模板的字符串部分。JavaScript理应由JavaScript引擎进行处理，字符串部分由Jack的i18n标签进行处理。使用者可以通过i18n的文档了解到，:c(CAD)代表加拿大元的货币单位。 这就是标签模板的大部分实际应用了。 模板字符串不能代替Mustache和Nunjucks，一部分原因是在模板字符串没有内建的循环或条件语句语法。我们一起来看如何解决这个问题，如果JS不提供这个特性，我们就写一个标签来提供相应支持。123456789// 基于纯粹虚构的模板语言// ES6标签模板。var libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; 标签模板带来的灵活性远不止于此，要记住，标签函数的参数不会自动转换为字符串，它们如返回值一样，可以是任何值，标签模板甚至不一定要是字符串！你可以用自定义的标签来创建正则表达式、DOM树、图片、以promises为代表的整个异步过程、JS数据结构、GL着色器…… 标签模板以开放的姿态欢迎库设计者们来创建强有力的领域特定语言。这些语言可能看起来不像JS，但是它们仍可以无缝嵌入到JS中并与JS的其它语言特性智能交互。我不知道这一特性将会带领我们走向何方，但它蕴藏着无限的可能性，这令我感到异常兴奋！ 我什么时候可以开始使用这一特性？在服务器端，io.js支持ES6的模板字符串。 在浏览器端，Firefox 34+支持模板字符串。它们由去年夏天的实习生项目组里的Guptha Rajagopal实现。模板字符串同样在Chrome 41+中得以支持，但是IE和Safari都不支持。到目前为止，如果你想要在web端使用模板字符串的功能，你将需要Babel或Traceur协助你完成ES6到ES5的代码转译，你也可以在TypeScript中立即使用这一特性。 等等——那么Markdown呢？嗯？ 哦…这是个好问题。 （这一章节与JavaScript无关，如果你不使用Markdown，可以跳过这一章。） 对于模板字符串而言，Markdown和JavaScript现在都使用`字符来表示一些特殊的事物。事实上，在Markdown中，反撇号用来分割在内联文本中间的代码片段。 这会带来许多问题！如果你在Markdown中写这样的文档： To display a message, write alert(hello world!).它将这样显示： To display a message, write alert(hello world!).请注意，输出文本中的反撇号消失了。Markdown将所有的四个反撇号解释为代码分隔符并用HTML标签将其替换掉。 为了避免这样的情况发生，我们要借助Markdown中的一个鲜为人知的特性，你可以使用多行反撇号作为代码分隔符，就像这样： To display a message, write alert(`hello world!`).在这个Gist有具体代码细节，它由Markdown写成，所以你可以直接查看源代码。 转载：作者 Jason Orendorff github主页 https://github.com/jorendorff]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模板字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作轮播2]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F03%2F%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD2%2F</url>
    <content type="text"><![CDATA[将轮播进一步修改为无缝轮播思路用 js 精确控制哪一张显示，哪一张不显示。即不能让图片横向排开，而是每一张图片进行绝对定位，从而保证每张图片的独立性。 代码地址： https://tongwenqian.github.io/slides2-demo/]]></content>
      <categories>
        <category>前端</category>
        <category>作品制作</category>
      </categories>
      <tags>
        <tag>轮播制作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作轮播]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F03%2F%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[制作轮播欣赏轮播的例子 苹果风格的轮播Demo: http://demo.tutorialzine.com/2009/11/beautiful-apple-gallery-slideshow/demo.html英文教程： http://tutorialzine.com/2009/11/beautiful-apple-gallery-slideshow/ 科技感十足的轮播Demo: http://idangero.us/swiper/源码： https://github.com/nolimits4web/swiper/ 轮播组件（可以直接使用）预览： http://idangero.us/swiper/demos/GitHub： https://github.com/nolimits4web/swiper/ 轮播的思路显示一个小窗口，图片放置在小窗口的后面，超出小窗口的图片 overflow:hidden 即可。移动图片实现轮播。 开始制作轮播做一个粗略的轮播123456789101112131415161718192021222324252627282930313233343536/**html**/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;//code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .images&#123; display: flex; align-items:flex-start; transition: transform 0.5s; &#125; .images&gt;img&#123; vertical-align:top; &#125; .window&#123; width:300px; overflow:hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;window&quot;&gt; &lt;div class=&quot;images&quot; id=images&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot; height=200&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;p1&quot;&gt;第1张&lt;/button&gt; &lt;button id=&quot;p2&quot;&gt;第2张&lt;/button&gt; &lt;button id=&quot;p3&quot;&gt;第3张&lt;/button&gt;&lt;/body&gt;&lt;/html 12345678910111213141516/**js**/$(p1).on(&apos;click&apos;,function()&#123; $(images).css(&#123; transform: &apos;translateX(0)&apos; &#125;)&#125;)$(p2).on(&apos;click&apos;,function()&#123; $(images).css(&#123; transform: &apos;translateX(-300px)&apos; &#125;)&#125;)$(p3).on(&apos;click&apos;,function()&#123; $(images).css(&#123; transform: &apos;translateX(-600px)&apos; &#125;)&#125;) 预览： http://js.jirengu.com/rutafinori/9/editJS Bin 改进轮播 首先，肯定想到要避免 js 操作 css。（见“内容、样式、行为分离的理解”），但是这个例子中严格分离的话代码变得更复杂麻烦了，因此这里稍微违反一下，灵活运用。 实现图片自动播放 12345678910111213141516171819202122232425262728293031323334353637383940 /**html**/ &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;//code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .images&#123; display: flex; align-items:flex-start; transition: transform 0.5s; &#125; .images&gt;img&#123; vertical-align:top; &#125; .window&#123; width:300px; overflow:hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;window&quot;&gt; &lt;div class=&quot;images&quot; id=images&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot; height=200&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;span id=buttons&gt; &lt;span&gt;第1张&lt;/span&gt; &lt;span&gt;第2张&lt;/span&gt; &lt;span&gt;第3张&lt;/span&gt; &lt;span&gt;第4张&lt;/span&gt; &lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /**js**/ var allButtons = $(&apos;#buttons&gt;span&apos;)for(let i=0;i&lt;allButtons.length;i++)&#123; $(allButtons[i]).on(&apos;click&apos;,function(x)&#123; var index = $(x.currentTarget).index() var p = index*-300 $(&apos;#images&apos;).css(&#123; transform: &apos;translateX(&apos;+p+&apos;px)&apos; &#125;) n = index activeButton(allButtons.eq(n)) &#125;)&#125;var n = 0;var size = allButtons.lengthplaySlide(n%size)var timeId = setTimer()$(&apos;.window&apos;).on(&apos;mouseenter&apos;,function()&#123; window.clearInterval(timeId)&#125;)$(&apos;.window&apos;).on(&apos;mouseleave&apos;,function()&#123; timeId = setTimer()&#125;)function activeButton($button)&#123; $button .addClass(&apos;red&apos;) .siblings(&apos;.red&apos;).removeClass(&apos;red&apos;)&#125;function playSlide(index)&#123; allButtons.eq(index).trigger(&apos;click&apos;)&#125;function setTimer()&#123; return setInterval(()=&gt;&#123; n += 1 playSlide(n%size)&#125;,1000)&#125; 1234 /**css**/ .red&#123; color:red;&#125; 预览： http://js.jirengu.com/rumemisoji/3/editJS Bin]]></content>
      <categories>
        <category>前端</category>
        <category>作品制作</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容、样式、行为分离的理解]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F02%2F%E5%86%85%E5%AE%B9%E6%A0%B7%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%88%86%E7%A6%BB%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTML , CSS , JS 内容、样式与行为分离的理解 这个问题与人为什么要吃饭一样，正面回答十分麻烦。对于这种看似理所应当的问题，反方向回答 格式：如果不。。。/如果这样，会导致什么后果 回答： 如果 HTML 负责样式，会使 HTML 很复杂（有的标签标示内容，有的标签标示样式），很难区分这些标签的逻辑结构。 如果 CSS 标示内容，用户选不中，JS也很难取到 12345678910//举例：/**html**/&lt;div&gt;&lt;/div&gt;/**css**/div::after&#123; content:&apos;你好&apos;&#125;/**js**/console.log(x.innerText)//控制台取不到“你好”//显示出来的“你好”用户也选不中 如果 CSS 负责行为，若是 CSS 中有很多很复杂的逻辑，会使得 CSS 很慢，导致网页也会变慢。 如果 JS 控制样式12345678//举例：$div.show(),$div.hide() 一般是禁止使用的/**html**/&lt;div id=x&gt;你好&lt;/div&gt;//display:flex/**js**/var $div = $(&apos;#x&apos;)$div.hide()//display:none$div.show()//display:flex ,不是 block//若div最初的display为none，则$div.show()之后display为block，十分不准，很难预测]]></content>
      <categories>
        <category>前端</category>
        <category>前端问题汇总</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解jQuery]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F02%2F%E4%BA%86%E8%A7%A3jQuery%2F</url>
    <content type="text"><![CDATA[jQuery 简介 jQuery 是目前使用最广泛的 javascript 函数库。据统计，全世界排名前100万的网站，有46%使用 jQuery，远远超过其他库。微软公司甚至把 jQuery 作为他们的官方库。对于网页开发者来说，学会 jQuery 是必要的。因为它让你了解业界最通用的技术，为将来学习更高级的库打下基础，并且确实可以很轻松地做出许多复杂的效果。虽然 jQuery 上手简单，比其他库容易学会，但是要全面掌握，却不轻松。因为它涉及到网页开发的方方面面，提供的各种方法和内部变化有上千种之多。初学者常常感到，入门很方便，提高很困难。 目前，互联网上最好的 jQuery 入门教材，是 Rebecca Murphey 写的《jQuery基础》（jQuery Fundamentals）。在 Google 里搜索“jQuery培训”，此书排在第一位。jQuery 官方团队已经同意，把此书作为官方教程的基础。 了解 jQuery自己动手封装函数首先，尝试自己封装函数，分别是： function getSiblings(node){} function addClass(node, classes){} 12345678/**HTML**/&lt;ul&gt; &lt;li id=&quot;item1&quot;&gt;选项1&lt;/li&gt; &lt;li id=&quot;item2&quot;&gt;选项2&lt;/li&gt; &lt;li id=&quot;item3&quot;&gt;选项3&lt;/li&gt; &lt;li id=&quot;item4&quot;&gt;选项4&lt;/li&gt; &lt;li id=&quot;item5&quot;&gt;选项5&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627/**JS**/function getSiblings(node)&#123;/*API*/ var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; for(let i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== item3)&#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125; console.log(getSiblings(item3))function addClass(node,classes)&#123; for(let key in classes)&#123; var value = classes[key] if(value)&#123; node.classList.add(key) &#125;else&#123; node.classList.remove(key) &#125; &#125;&#125;addClass(item3,&#123;a:true,b:false,c:true&#125;) 命名空间为了让上面两个API看起来是相关联的，那么就声明一个变量tdom，使它们有关联1234567/**JS**/window.tdom = &#123;&#125;tdom.getSiblings = getSiblingstdom.addClass = addClasstdom.getSinblings(item3)tdom.addClass(item3,&#123;a:true,b:false,c:true&#125;) 123var dom = &#123;&#125;dom.getSiblings(node)dom.addClass(node, &#123;a: true, b: false&#125;) 进一步，改 node 原型1234/**CSS**/.blue&#123; color:blue;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/**JS**/window.tdom = &#123;&#125; /*yui*/ffdom.getSiblings = function (node) &#123; /* API */ var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;tdom.addClass = function (node, classes) &#123; classes.forEach( (value) =&gt; node.classList.add(value) )&#125;tdom.getSiblings(item3)tdom.addClass(item3, [&apos;blue&apos;,&apos;b&apos;,&apos;c&apos;])Node.prototype.getSiblings = function()&#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;item3.getSiblings() 能不能把 node 放在前面12node.getSiblings()node.addClass() 方法一：扩展 Node 接口直接在 Node.prototype 上加函数 方法二：新的接口 BetterNode 123456789101112131415function Node2(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById(&apos;x&apos;)let node2 = Node2(node)node2.getSiblings()node2.addClass() 第二种叫做“无侵入” 把 Node2 改个名字吧123456789101112131415function jQuery(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById(&apos;x&apos;)let node2 =jQuery(node)node2.getSiblings()node2.addClass() 再给个缩写吧 aliaswindow.$ = jQuery jQuery 中文文档地址：http://cndevdocs.com/ 根据jQuery中文文档，以.addClass()为例的简单使用 123456789/**HTML**/&lt;ul&gt; &lt;li&gt;选项1&lt;/li&gt; &lt;li&gt;选项2&lt;/li&gt; &lt;li&gt;选项3&lt;/li&gt; &lt;li&gt;选项4&lt;/li&gt; &lt;li&gt;选项5&lt;/li&gt;&lt;/ul&gt;&lt;button id=&quot;x&quot;&gt;x&lt;button&gt; 12345678910111213141516/**CSS**/.red&#123; color:red;&#125;.blue&#123; color:blue;&#125;.green&#123; color:green;&#125;.yellow&#123; color:yellow;&#125;.black&#123; color:black;&#125; 123456789101112131415/**JS**/var nodes = jQuery(&apos;ul&gt;li&apos;)//例子1nodes.addClass(&apos;red&apos;)//例子2x.onclick = function()&#123; nodes.toggleClass(&apos;red&apos;)//toggle切换 开关&#125;//例子3var classes = &#123;&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;yellow&apos;,&apos;black&apos;&#125;x.onclick = function()&#123; nodes.addClass(function(index,currentClass)&#123; return classes[index] &#125;)&#125; jQuery 优点 jQuery 在兼容性方面做得很好，1.7 版本兼容到 IE 6 jQuery 还有动画、AJAX 等模块，不止 DOM 操作 jQuery 的功能更丰富 jQuery 使用了 prototype 参考：http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html]]></content>
      <categories>
        <category>前端</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下命令行常用技巧]]></title>
    <url>%2FTongWenQian%2F2019%2F05%2F31%2FWindows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用z进行快速跳跃 mkdir ~/repos cd ~/repos git clone https://github.com/rupa/z.git touch ~/.bashrc start ~/.bashrc在文件里写： 12. ~/repos/z/z.sh alias j=&apos;z&apos; 重启 Git Bash 你去过的所有目录都会被记录了！使用 j XXX 就可以快速到达之前去过的目录了！ 使用 j 可以查看所有去过的目录注意，~/repos/z/z.sh 不能删除，删除了就不能用了 使用 bash alias 快速输入命令注意echo ‘xxx’ &gt; ~/.bashrc 会覆盖文件的所有内容，请提前备份 ~/.bashrc！！把 &gt; 换成 &gt;&gt; 才是追加内容 代码(方便日后查阅)1234567891011121314151617. ~/GitHub/z/z.shexport PYTHONIOENCODING=UTF-8export LANG=&apos;en_US.UTF-8&apos;export LC_ALL=&apos;en_US.UTF-8&apos;alias j=&apos;z&apos;alias gst=&quot;git status -sb&quot;alias ga=&quot;git add&quot;alias gc=&quot;git commit -v&quot;alias gcc=&quot;git commit . -m update&quot;alias gp=&quot;git push&quot;alias gl=&quot;git pull&quot;alias open=&quot;start&quot;alias ll=&quot;ls -la&quot;alias glog=&quot;git log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit -- | less&quot; 让Windows支持tree 下载 GnuTree.exe 双击安装，一路下一步（注意安装路径里不要有空格，建议安装在 C:\Software\GnuWin32 将 C:\Software\GnuWin32\bin 添加到 PATH 里，添加方法如下：i. Git Bash 添加方法a. 运行 touch ~/.bashrc; echo &apos;export PATH=&quot;$PATH:/c/Software/GnuWin32/bin/&quot;&apos; &gt;&gt; ~/.bashrc b. 重启 Git Bash ii. 图形界面添加方法（推荐使用上面一种方法）a. 在 Windows 的环境变量 PATH 里添加 C:\Software\GnuWin32\bin b. 如果不知道 Windows 怎么添加环境变量 PATH，百度『Windows 环境变量 PATH』即可 然后你就可以运行 tree 命令了 安装curl 搜索 scoop.sh ，按照官网要求安装(卸载： uninstall scoop) 打开 Windows PowerShell ，粘贴在官网复制的命令行 打开 Git Bash ，输入： which scoop 查看是否已经安装成功 scoop install curl 命令行快捷翻译（fy xxx） npm i -g fanyi echo &quot;alias yd=&#39;fanyi&#39;&quot; &gt;&gt; ~/.bashrc如果提示 commond not found，就需要更新 PATHexport PATH=&quot;xxx:$PATH&quot;其中 xxx 的示例为 /c/Users/lev/AppData/Roaming/npm 命令行常用快捷键 Ctrl + R 搜索历史，再次 Ctrl + R 切换（按左右键，退出选择且并未执行；若直接按回车，退出选择且执行命令行） Ctrl + A 行首 Ctrl + E 行尾 Ctrl + B 退后 Ctrl + F 前进 Ctrl + W 删一个单词 Ctrl + K 删掉这一行（首先要 Ctrl + A 来到行首才能删） Ctrl + C 中断 Ctrl + G 退出搜索 Alt + . 使用上一行命令的最后一个参数 快捷复制粘贴Git Bash 选中即为复制 按鼠标中键粘贴/Shift + insert CMD 选中再回车复制 右键粘贴 软件推荐ConEmu你也可以尝试 cmder， cmder 是基于 ConEmu 上面改的。 Fira Mono For Powerline 一键呼起（本人设置F1） 分屏（本人设置上下分屏： Alt + Shift + D ，左右分屏： Alt + D ，退出分屏：点击某一个分屏，按 Ctrl + D) 剪切板管理软件 ClipboardFusionCtrl + Shift + v 历史复制内容查看 截图软件 Snipaste]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows命令行技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo与GitHub建立博客]]></title>
    <url>%2FTongWenQian%2F2019%2F05%2F31%2FHexo%E4%B8%8EGitHub%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[主要步骤 进入一个安全的目录，比如 cd ~/Desktop 或者 cd ~/Documents，别在根目录 / 建博客。 在 GitHub 上新建一个空 repo，repo 名称是「你的用户名.github.io」（注意个用户名是你的GitHub用户名，不是你的电脑用户名） npm install -g hexo-cli，安装 Hexo hexo init myBlog cd myBlog npm i hexo new 开博大吉，你会看到一个 md 文件的路径 注意：Windows 的路径中的 \ 需要变成 / 才行 运行 start source/_post/开博大吉.md 来编辑这个 md 文件，内容自己想（Ubuntu 系统用 xdg-open xxxxxxxxxxxxxxxxxxx.md 命令） 举例：如果 Windows 提示的是 INFO created: ~\Desktop\myBlog\source_posts\开博大吉.md那么你的命令就应该是 start “~/Desktop/myBlog/source/_posts/开博大吉.md” 注意引号和斜杠，如果路径里没有空格，就不需要引号。 内容示例-–title: 开博大吉-– # 哈哈我的博客开通啦 start _config.yml，编辑网站配置 把第 6 行的 title 改成你想要的名字 把第 9 行的 author 改成你的大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址以 git@github.com: 开头。注意repo:后面有一个空格） npm install hexo-deployer-git --save，安装 git 部署插件 hexo deploy 进入「你的用户名.github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接 用浏览器访问「预览链接/index.html」就应该看到了你的博客！（GitHub Pages 存在延迟，如果没看到，过三分钟再刷新看看） 第二篇博客 hexo new 第二篇博客 复制显示的路径，使用 start 路径 来编辑它 hexo generate hexo deploy 去看你的博客，应该能看到第二篇博客了 换主题 https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集 随便找一个主题，进入主题的 GitHub 首页，比如我找的是 https://github.com/theme-next/hexo-theme-next 复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git cd myBlog git clone https://github.com/theme-next/hexo-theme-next themes/next 将 _config.yml 的第 76 行改为 theme: next，保存 hexo generate hexo deploy 等一分钟，然后刷新你的博客页面，你会看到一个新的外观。如果不喜欢这个主题，就回到第 1 步，重选一个主题。 上传源代码注意「你的用户名.github.io」上保存的只是你的博客，并没有保存「生成博客的程序代码」，你需要再创建一个名为 blog-generator 的空仓库，用来保存 myBlog 里面的「生成博客的程序代码」。 在 GitHub 创建 blog-generator 空仓库 按照截图中的命令执行即可 这样一来，你的博客发布在了「你的用户名.github.io」而你的「生成博客的程序代码」发布在了 blog-generator。所有数据万无一失，你就不会因为误删 myBlog 目录而痛哭了。以后每次 hexo deploy 完之后，博客就会更新；然后你还要要 add / commit /push 一下「生成博客的程序代码」，以防万一。这个 blog-generator 就是用来生成博客的程序，而「你的用户名.github.io」仓库就是你的博客页面。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
