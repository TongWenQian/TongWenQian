<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[每日练习-Linux命令行基础]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F05%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux 命令基础 什么是绝对路径？什么是相对路径？答：绝对路径是指文件或者目录在硬盘上真正的路径，例如 E:/user/1.png ，”/“开头，代表根目录。相对路径是指相对于当前的文件的路径。例如：./1.png 表示当前目录下的 1.png 图片。 如何查看当前位置的绝对路径？答： 在当前位置输入 pwd 命令。 如何查看系统的当前用户？答： 使用命令 whoami。 如何查看某个脚本命令的位置？（比如node)答： 以 node 为例，使用命令 which node。 请问使用||命令输出的当前路径下的文件信息中，前面的 -rwxr-xr-x 是什么意思？答: 以从左到右顺序解释： 1) 开头的 - 表示：文件 2) r：可读 3) w：可写 4) x：表示可执行 5) 第一个 r-x：用户所在组的权限 6) 第二个 r-x：任意用户权限 **.*、./*、*.png 分别代表什么意思？答：代表如下： **.*：所有 xx.xx 格式的文件 ./*：表示当前目录下的所有文件和所有目录 *.png: 以 .png 结尾的文件 sudo 是什么意思？答： sudo 即 super user do ,它的意思是用超级管理员的权限执行（do）。 echo ‘aaa’ &gt; a.txt 与 echo ‘bbb’ &gt;&gt; b.txt 有什么区别？答： echo ‘aaa’ &gt; a.txt 表示创建一个 a.txt (如果a.txt不存在）文件，并在 a.txt 中添加 aaa 内容，若再次往 a.txt 添加内容，会覆盖之前的内容。而 echo ‘bbb’ &gt;&gt; b.txt 表示在 b.txt 追加内容，不会覆盖本来就有的文件内容。 cat 命令能做什么？答：可以进行如下使用： cat filename：显示该文件内容 cat &gt; filename：创建一个文件 cat filename1 filename2 &gt; filename：将两个文件合并成一个文件 chmod +777 a.sh 是什么意思？ chmod 是什么？+777 是什么意思？答： 表示任何人对 a.sh 都有读、写、运行三项权限。chmod 是目录或者文件权限设置的命令。由于读、写、运行三项权限可以用数字来表示，r=4,w=2,x=1，因此 777 表示 rwxrwxrwx ，即为该用户和其所在的组以及其他人都有最高的权限。]]></content>
      <categories>
        <category>前端</category>
        <category>每日练习</category>
      </categories>
      <tags>
        <tag>每日练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出ES6（四）：模板字符串（转载）]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F04%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAES6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[深入浅出ES6（四）：模板字符串反撇号（`）基础知识ES6引入了一种新型的字符串字面量语法，我们称之为模板字符串（template strings）。除了使用反撇号字符 ` 代替普通字符串的引号 ‘ 或 “ 外，它们看起来与普通字符串并无二致。在最简单的情况下，它们与普通字符串的表现一致：1context.fillText(`Ceci n&apos;est pas une chaîne.`, x, y); 但是我们并没有说：“原来只是被反撇号括起来的普通字符串啊”。模板字符串名之有理，它为JavaScript提供了简单的字符串插值功能，从此以后，你可以通过一种更加美观、更加方便的方式向字符串中插值了。模板字符串的使用方式成千上万，但是最让我会心一暖的是将其应用于毫不起眼的错误消息提示：123456function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( `用户 $&#123;user.name&#125; 未被授权执行 $&#123;action&#125; 操作。`); &#125;&#125; 在这个示例中，${user.name}和${action}被称为模板占位符，JavaScript将把user.name和action的值插入到最终生成的字符串中，例如：用户jorendorff未被授权打冰球。（这是真的，我还没有获得冰球许可证。）到目前为止，我们所了解到的仅仅是比 + 运算符更优雅的语法，下面是你可能期待的一些特性细节： 模板占位符中的代码可以是任意JavaScript表达式，所以函数调用、算数运算等这些都可以作为占位符使用，你甚至可以在一个模板字符串中嵌套另一个，我称之为模板套构 （template inception）。 如果这两个值都不是字符串，可以按照常规将其转换为字符串。例如：如果action是一个对象，将会调用它的.toString()方法将其转换为字符串值。 如果你需要在模板字符串中书写反撇号，你必须使用反斜杠将其转义：\`等价于”`”。 同样地，如果你需要在模板字符串中引入字符$和{。无论你要实现什么样的目标，你都需要用反斜杠转义每一个字符：\$和\{。与普通字符串不同的是，模板字符串可以多行书写：12345$(&quot;#warning&quot;).html(` &lt;h1&gt;小心！&gt;/h1&gt; &lt;p&gt;未经授权打冰球可能受罚 将近$&#123;maxPenalty&#125;分钟。&lt;/p&gt;`); 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 好啦，我说过要让你们轻松掌握模板字符串，从现在起难度会加大，你可以到此为止，去喝一杯咖啡，慢慢消化之前的知识。真的，及时回头不是一件令人感到羞愧的事情。Lopes Gonçalves曾经向我们证明过，船只不会被海妖碾压，也不会从地球的边缘坠落下去，他最终跨越了赤道，但是他有继续探索整个南半球么？并没有，他回家了，吃了一顿丰盛的午餐，你一定不排斥这样的感觉。 反撇号的未来当然，模板字符串也并非事事包揽： 它们不会为你自动转义特殊字符，为了避免跨站脚本漏洞，你应当像拼接普通字符串时做的那样对非置信数据进行特殊处理。 它们无法很好地与国际化库（可以帮助你面向不同用户提供不同的语言）相配合，模板字符串不会格式化特定语言的数字和日期，更别提同时使用不同语言的情况了。 它们不能替代模板引擎的地位，例如：Mustache、Nunjucks。模板字符串没有内建循环语法，所以你无法通过遍历数组来构建类似HTML中的表格，甚至它连条件语句都不支持。你当然可以使用模板套构（template inception）的方法实现，但在我看来这方法略显愚钝啊。 不过，ES6为JS开发者和库设计者提供了一个很好的衍生工具，你可以借助这一特性突破模板字符串的诸多限制，我们称之为标签模板（tagged templates）。 标签模板的语法非常简单，在模板字符串开始的反撇号前附加一个额外的标签即可。我们的第一个示例将添加一个SaferHTML标签，我们要用这个标签来解决上述的第一个限制：自动转义特殊字符。 请注意，ES6标准库不提供类似SaferHTML功能，我们将在下面自己来实现这个功能。12var message = SaferHTML`&lt;p&gt;$&#123;bonk.sender&#125; 向你示好。&lt;/p&gt;`; 这里用到的标签是一个标识符SaferHTML；也可以使用属性值作为标签，例如：SaferHTML.escape；还可以是一个方法调用，例如：SaferHTML.escape({unicodeControlCharacters: false})。精确地说，任何ES6的成员表达式（MemberExpression）或调用表达式（CallExpression）都可作为标签使用。可以看出，无标签模板字符串简化了简单字符串拼接，标签模板则完全简化了函数调用！上面的代码等效于：12var message = SaferHTML(templateData, bonk.sender); templateData是一个不可变数组，存储着模板所有的字符串部分，由JS引擎为我们创建。因为占位符将标签模板分割为两个字符串的部分，所以这个数组内含两个元素，形如Object.freeze([&quot;&lt;p&gt;&quot;, &quot; has sent you a bonk.&lt;/p&gt;&quot;]。 （事实上，templateData中还有一个属性，在这篇文章中我们不会用到，但是它是标签模板不可分割的一环：templateData.raw，它同样是一个数组，存储着标签模板中所有的字符串部分，如果我们查看源码将会发现，在这里是使用形如\n的转义序列分行，而在templateData中则为真正的新行，标准标签String.raw会用到这些原生字符串。） 如此一来，SaferHTML函数就可以有成千上万种方法来解析字符串和占位符。 在继续阅读以前，可能你苦苦思索到底用SaferHTML来做什么，然后着手尝试去实现它，归根结底，它只是一个函数，你可以在Firefox的开发者控制台里测试你的成果。 以下是一种可行的方案（在gist中查看）：123456789101112131415function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); // 转义占位符中的特殊字符。 s += arg.replace(/&amp;/g, &quot;&amp;&quot;) .replace(/&lt;/g, &quot;&lt;&quot;) .replace(/&lt;/g, &quot;&gt;&quot;); // 不转义模板中的特殊字符。 s += templateData[i]; &#125; return s;&#125; 通过这样的定义，标签模板SaferHTML&lt;p&gt;${bonk.sender} 向你示好。&lt;/p&gt; 可能扩展为字符串 “&lt;p&gt;ES6&lt;3er 向你示好。&lt;/p&gt;“。即使一个恶意命名的用户，例如“黑客Steve&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;”，向其他用户发送一条骚扰信息，无论如何这条信息都会被转义为普通字符串，其他用户不会受到潜在攻击的威胁。 （顺便一提，如果你感觉上述代码中在函数内部使用参数对象的方式令你感到枯燥乏味，不妨期待下一篇大作，ES6中的另一个新特性一定会让你眼前一亮！） 仅一个简单的示例不足以说明标签模板的灵活性，我们一起回顾下我们之前有关模板字符串限制的列表，看一下你还能做些什么不一样的事情。 模板字符串不会自动转义特殊字符。但是正如我们看到的那样，通过标签模板，你可以自己写一个标签函数来解决这个问题 事实上，你可以做的比那更好。 站在安全角度来说，我实现的SaferHTML函数相当脆弱，你需要通过多种不同的方式将HTML不同部分的特殊字符转义，SaferHTML就无法做到全部转义。但是稍加努力，你就可以写出一个更加智能的SaferHTML函数，它可以针对templateData中字符串中的HTML位进行解析，分析出哪一个占位符是纯HTML；哪一个是元素内部属性，需要转义’和”；哪一个是URL的query字符串，需要进行URL转义而非HTML转义，等等。智能SaferHTML函数可以将每个占位符都正确转义。 HTML的解析速度很慢，这种方法听起来是否略显牵强？幸运的是，当模板重新求值的时候标签模板的字符串部分是不改变的。SaferHTML可以缓存所有的解析结果，来加速后续的调用。（缓存可以按照ES6的另一个特性——WeakMap的形式进行存储，我们将在未来的文章中继续深入讨论。） 模板字符串没有内建的国际化特性，但是通过标签，我们可以添加这些功能。Jack Hsu的一篇博客文章展示了具体的实现过程。我谨在此处抛砖引玉：i18nHello ${name}, you have ${amount}:c(CAD) in your bank account.// =&gt; Hallo Bob, Sie haben 1.234,56 $CA auf Ihrem Bankkonto. 注意观察这个示例中的运行细节，name和amount都是JavaScript，进行正常插值处理，但是有一段与众不同的代码，:c(CAD)，Jack将它放入了模板的字符串部分。JavaScript理应由JavaScript引擎进行处理，字符串部分由Jack的i18n标签进行处理。使用者可以通过i18n的文档了解到，:c(CAD)代表加拿大元的货币单位。 这就是标签模板的大部分实际应用了。 模板字符串不能代替Mustache和Nunjucks，一部分原因是在模板字符串没有内建的循环或条件语句语法。我们一起来看如何解决这个问题，如果JS不提供这个特性，我们就写一个标签来提供相应支持。123456789// 基于纯粹虚构的模板语言// ES6标签模板。var libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; 标签模板带来的灵活性远不止于此，要记住，标签函数的参数不会自动转换为字符串，它们如返回值一样，可以是任何值，标签模板甚至不一定要是字符串！你可以用自定义的标签来创建正则表达式、DOM树、图片、以promises为代表的整个异步过程、JS数据结构、GL着色器…… 标签模板以开放的姿态欢迎库设计者们来创建强有力的领域特定语言。这些语言可能看起来不像JS，但是它们仍可以无缝嵌入到JS中并与JS的其它语言特性智能交互。我不知道这一特性将会带领我们走向何方，但它蕴藏着无限的可能性，这令我感到异常兴奋！ 我什么时候可以开始使用这一特性？在服务器端，io.js支持ES6的模板字符串。 在浏览器端，Firefox 34+支持模板字符串。它们由去年夏天的实习生项目组里的Guptha Rajagopal实现。模板字符串同样在Chrome 41+中得以支持，但是IE和Safari都不支持。到目前为止，如果你想要在web端使用模板字符串的功能，你将需要Babel或Traceur协助你完成ES6到ES5的代码转译，你也可以在TypeScript中立即使用这一特性。 等等——那么Markdown呢？嗯？ 哦…这是个好问题。 （这一章节与JavaScript无关，如果你不使用Markdown，可以跳过这一章。） 对于模板字符串而言，Markdown和JavaScript现在都使用`字符来表示一些特殊的事物。事实上，在Markdown中，反撇号用来分割在内联文本中间的代码片段。 这会带来许多问题！如果你在Markdown中写这样的文档： To display a message, write alert(hello world!).它将这样显示： To display a message, write alert(hello world!).请注意，输出文本中的反撇号消失了。Markdown将所有的四个反撇号解释为代码分隔符并用HTML标签将其替换掉。 为了避免这样的情况发生，我们要借助Markdown中的一个鲜为人知的特性，你可以使用多行反撇号作为代码分隔符，就像这样： To display a message, write alert(`hello world!`).在这个Gist有具体代码细节，它由Markdown写成，所以你可以直接查看源代码。 转载：作者 Jason Orendorff github主页 https://github.com/jorendorff]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模板字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作轮播2]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F03%2F%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD2%2F</url>
    <content type="text"><![CDATA[将轮播进一步修改为无缝轮播思路用 js 精确控制哪一张显示，哪一张不显示。即不能让图片横向排开，而是每一张图片进行绝对定位，从而保证每张图片的独立性。 代码地址： https://github.com/TongWenQian/slides-2-demo]]></content>
      <categories>
        <category>前端</category>
        <category>作品制作</category>
      </categories>
      <tags>
        <tag>轮播制作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作轮播]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F03%2F%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[制作轮播欣赏轮播的例子 苹果风格的轮播Demo: http://demo.tutorialzine.com/2009/11/beautiful-apple-gallery-slideshow/demo.html英文教程： http://tutorialzine.com/2009/11/beautiful-apple-gallery-slideshow/ 科技感十足的轮播Demo: http://idangero.us/swiper/源码： https://github.com/nolimits4web/swiper/ 轮播组件（可以直接使用）预览： http://idangero.us/swiper/demos/GitHub： https://github.com/nolimits4web/swiper/ 轮播的思路显示一个小窗口，图片放置在小窗口的后面，超出小窗口的图片 overflow:hidden 即可。移动图片实现轮播。 开始制作轮播做一个粗略的轮播123456789101112131415161718192021222324252627282930313233343536/**html**/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;//code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .images&#123; display: flex; align-items:flex-start; transition: transform 0.5s; &#125; .images&gt;img&#123; vertical-align:top; &#125; .window&#123; width:300px; overflow:hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;window&quot;&gt; &lt;div class=&quot;images&quot; id=images&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot; height=200&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;p1&quot;&gt;第1张&lt;/button&gt; &lt;button id=&quot;p2&quot;&gt;第2张&lt;/button&gt; &lt;button id=&quot;p3&quot;&gt;第3张&lt;/button&gt;&lt;/body&gt;&lt;/html 12345678910111213141516/**js**/$(p1).on(&apos;click&apos;,function()&#123; $(images).css(&#123; transform: &apos;translateX(0)&apos; &#125;)&#125;)$(p2).on(&apos;click&apos;,function()&#123; $(images).css(&#123; transform: &apos;translateX(-300px)&apos; &#125;)&#125;)$(p3).on(&apos;click&apos;,function()&#123; $(images).css(&#123; transform: &apos;translateX(-600px)&apos; &#125;)&#125;) 预览： http://js.jirengu.com/rutafinori/9/editJS Bin 改进轮播 首先，肯定想到要避免 js 操作 css。（见“内容、样式、行为分离的理解”），但是这个例子中严格分离的话代码变得更复杂麻烦了，因此这里稍微违反一下，灵活运用。 实现图片自动播放 12345678910111213141516171819202122232425262728293031323334353637383940 /**html**/ &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;//code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .images&#123; display: flex; align-items:flex-start; transition: transform 0.5s; &#125; .images&gt;img&#123; vertical-align:top; &#125; .window&#123; width:300px; overflow:hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;window&quot;&gt; &lt;div class=&quot;images&quot; id=images&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot; height=200&gt; &lt;img src=&quot;https://canna-pet.com/wp-content/uploads/2017/06/20-longest-living-dog-breeds_canna-pet-e1498599846169.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;img src=&quot;https://fthmb.tqn.com/0ui_Zw01Ht9NHJkSBlqOIC1IH44=/960x0/filters:no_upscale()/yorkshire-terrier-583788122-581630e85f9b581c0b018a00.jpg&quot; width=300 alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;span id=buttons&gt; &lt;span&gt;第1张&lt;/span&gt; &lt;span&gt;第2张&lt;/span&gt; &lt;span&gt;第3张&lt;/span&gt; &lt;span&gt;第4张&lt;/span&gt; &lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /**js**/ var allButtons = $(&apos;#buttons&gt;span&apos;)for(let i=0;i&lt;allButtons.length;i++)&#123; $(allButtons[i]).on(&apos;click&apos;,function(x)&#123; var index = $(x.currentTarget).index() var p = index*-300 $(&apos;#images&apos;).css(&#123; transform: &apos;translateX(&apos;+p+&apos;px)&apos; &#125;) n = index activeButton(allButtons.eq(n)) &#125;)&#125;var n = 0;var size = allButtons.lengthplaySlide(n%size)var timeId = setTimer()$(&apos;.window&apos;).on(&apos;mouseenter&apos;,function()&#123; window.clearInterval(timeId)&#125;)$(&apos;.window&apos;).on(&apos;mouseleave&apos;,function()&#123; timeId = setTimer()&#125;)function activeButton($button)&#123; $button .addClass(&apos;red&apos;) .siblings(&apos;.red&apos;).removeClass(&apos;red&apos;)&#125;function playSlide(index)&#123; allButtons.eq(index).trigger(&apos;click&apos;)&#125;function setTimer()&#123; return setInterval(()=&gt;&#123; n += 1 playSlide(n%size)&#125;,1000)&#125; 1234 /**css**/ .red&#123; color:red;&#125; 预览： http://js.jirengu.com/rumemisoji/3/editJS Bin]]></content>
      <categories>
        <category>前端</category>
        <category>作品制作</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容、样式、行为分离的理解]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F02%2F%E5%86%85%E5%AE%B9%E6%A0%B7%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%88%86%E7%A6%BB%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTML , CSS , JS 内容、样式与行为分离的理解 这个问题与人为什么要吃饭一样，正面回答十分麻烦。对于这种看似理所应当的问题，反方向回答 格式：如果不。。。/如果这样，会导致什么后果 回答： 如果 HTML 负责样式，会使 HTML 很复杂（有的标签标示内容，有的标签标示样式），很难区分这些标签的逻辑结构。 如果 CSS 标示内容，用户选不中，JS也很难取到 12345678910//举例：/**html**/&lt;div&gt;&lt;/div&gt;/**css**/div::after&#123; content:&apos;你好&apos;&#125;/**js**/console.log(x.innerText)//控制台取不到“你好”//显示出来的“你好”用户也选不中 如果 CSS 负责行为，若是 CSS 中有很多很复杂的逻辑，会使得 CSS 很慢，导致网页也会变慢。 如果 JS 控制样式12345678//举例：$div.show(),$div.hide() 一般是禁止使用的/**html**/&lt;div id=x&gt;你好&lt;/div&gt;//display:flex/**js**/var $div = $(&apos;#x&apos;)$div.hide()//display:none$div.show()//display:flex ,不是 block//若div最初的display为none，则$div.show()之后display为block，十分不准，很难预测]]></content>
      <categories>
        <category>前端</category>
        <category>前端问题汇总</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解jQuery]]></title>
    <url>%2FTongWenQian%2F2019%2F06%2F02%2F%E4%BA%86%E8%A7%A3jQuery%2F</url>
    <content type="text"><![CDATA[jQuery 简介 jQuery 是目前使用最广泛的 javascript 函数库。据统计，全世界排名前100万的网站，有46%使用 jQuery，远远超过其他库。微软公司甚至把 jQuery 作为他们的官方库。对于网页开发者来说，学会 jQuery 是必要的。因为它让你了解业界最通用的技术，为将来学习更高级的库打下基础，并且确实可以很轻松地做出许多复杂的效果。虽然 jQuery 上手简单，比其他库容易学会，但是要全面掌握，却不轻松。因为它涉及到网页开发的方方面面，提供的各种方法和内部变化有上千种之多。初学者常常感到，入门很方便，提高很困难。 目前，互联网上最好的 jQuery 入门教材，是 Rebecca Murphey 写的《jQuery基础》（jQuery Fundamentals）。在 Google 里搜索“jQuery培训”，此书排在第一位。jQuery 官方团队已经同意，把此书作为官方教程的基础。 了解 jQuery自己动手封装函数首先，尝试自己封装函数，分别是： function getSiblings(node){} function addClass(node, classes){} 12345678/**HTML**/&lt;ul&gt; &lt;li id=&quot;item1&quot;&gt;选项1&lt;/li&gt; &lt;li id=&quot;item2&quot;&gt;选项2&lt;/li&gt; &lt;li id=&quot;item3&quot;&gt;选项3&lt;/li&gt; &lt;li id=&quot;item4&quot;&gt;选项4&lt;/li&gt; &lt;li id=&quot;item5&quot;&gt;选项5&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627/**JS**/function getSiblings(node)&#123;/*API*/ var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; for(let i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== item3)&#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125; console.log(getSiblings(item3))function addClass(node,classes)&#123; for(let key in classes)&#123; var value = classes[key] if(value)&#123; node.classList.add(key) &#125;else&#123; node.classList.remove(key) &#125; &#125;&#125;addClass(item3,&#123;a:true,b:false,c:true&#125;) 命名空间为了让上面两个API看起来是相关联的，那么就声明一个变量tdom，使它们有关联1234567/**JS**/window.tdom = &#123;&#125;tdom.getSiblings = getSiblingstdom.addClass = addClasstdom.getSinblings(item3)tdom.addClass(item3,&#123;a:true,b:false,c:true&#125;) 123var dom = &#123;&#125;dom.getSiblings(node)dom.addClass(node, &#123;a: true, b: false&#125;) 进一步，改 node 原型1234/**CSS**/.blue&#123; color:blue;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/**JS**/window.tdom = &#123;&#125; /*yui*/ffdom.getSiblings = function (node) &#123; /* API */ var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;tdom.addClass = function (node, classes) &#123; classes.forEach( (value) =&gt; node.classList.add(value) )&#125;tdom.getSiblings(item3)tdom.addClass(item3, [&apos;blue&apos;,&apos;b&apos;,&apos;c&apos;])Node.prototype.getSiblings = function()&#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;item3.getSiblings() 能不能把 node 放在前面12node.getSiblings()node.addClass() 方法一：扩展 Node 接口直接在 Node.prototype 上加函数 方法二：新的接口 BetterNode 123456789101112131415function Node2(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById(&apos;x&apos;)let node2 = Node2(node)node2.getSiblings()node2.addClass() 第二种叫做“无侵入” 把 Node2 改个名字吧123456789101112131415function jQuery(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById(&apos;x&apos;)let node2 =jQuery(node)node2.getSiblings()node2.addClass() 再给个缩写吧 aliaswindow.$ = jQuery jQuery 中文文档地址：http://cndevdocs.com/ 根据jQuery中文文档，以.addClass()为例的简单使用 123456789/**HTML**/&lt;ul&gt; &lt;li&gt;选项1&lt;/li&gt; &lt;li&gt;选项2&lt;/li&gt; &lt;li&gt;选项3&lt;/li&gt; &lt;li&gt;选项4&lt;/li&gt; &lt;li&gt;选项5&lt;/li&gt;&lt;/ul&gt;&lt;button id=&quot;x&quot;&gt;x&lt;button&gt; 12345678910111213141516/**CSS**/.red&#123; color:red;&#125;.blue&#123; color:blue;&#125;.green&#123; color:green;&#125;.yellow&#123; color:yellow;&#125;.black&#123; color:black;&#125; 123456789101112131415/**JS**/var nodes = jQuery(&apos;ul&gt;li&apos;)//例子1nodes.addClass(&apos;red&apos;)//例子2x.onclick = function()&#123; nodes.toggleClass(&apos;red&apos;)//toggle切换 开关&#125;//例子3var classes = &#123;&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;yellow&apos;,&apos;black&apos;&#125;x.onclick = function()&#123; nodes.addClass(function(index,currentClass)&#123; return classes[index] &#125;)&#125; jQuery 优点 jQuery 在兼容性方面做得很好，1.7 版本兼容到 IE 6 jQuery 还有动画、AJAX 等模块，不止 DOM 操作 jQuery 的功能更丰富 jQuery 使用了 prototype 参考：http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html]]></content>
      <categories>
        <category>前端</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下命令行常用技巧]]></title>
    <url>%2FTongWenQian%2F2019%2F05%2F31%2FWindows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用z进行快速跳跃 mkdir ~/repos cd ~/repos git clone https://github.com/rupa/z.git touch ~/.bashrc start ~/.bashrc在文件里写： 12. ~/repos/z/z.sh alias j=&apos;z&apos; 重启 Git Bash 你去过的所有目录都会被记录了！使用 j XXX 就可以快速到达之前去过的目录了！ 使用 j 可以查看所有去过的目录注意，~/repos/z/z.sh 不能删除，删除了就不能用了 使用 bash alias 快速输入命令注意echo ‘xxx’ &gt; ~/.bashrc 会覆盖文件的所有内容，请提前备份 ~/.bashrc！！把 &gt; 换成 &gt;&gt; 才是追加内容 代码(方便日后查阅)1234567891011121314151617. ~/GitHub/z/z.shexport PYTHONIOENCODING=UTF-8export LANG=&apos;en_US.UTF-8&apos;export LC_ALL=&apos;en_US.UTF-8&apos;alias j=&apos;z&apos;alias gst=&quot;git status -sb&quot;alias ga=&quot;git add&quot;alias gc=&quot;git commit -v&quot;alias gcc=&quot;git commit . -m update&quot;alias gp=&quot;git push&quot;alias gl=&quot;git pull&quot;alias open=&quot;start&quot;alias ll=&quot;ls -la&quot;alias glog=&quot;git log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit -- | less&quot; 让Windows支持tree 下载 GnuTree.exe 双击安装，一路下一步（注意安装路径里不要有空格，建议安装在 C:\Software\GnuWin32 将 C:\Software\GnuWin32\bin 添加到 PATH 里，添加方法如下：i. Git Bash 添加方法a. 运行 touch ~/.bashrc; echo &apos;export PATH=&quot;$PATH:/c/Software/GnuWin32/bin/&quot;&apos; &gt;&gt; ~/.bashrc b. 重启 Git Bash ii. 图形界面添加方法（推荐使用上面一种方法）a. 在 Windows 的环境变量 PATH 里添加 C:\Software\GnuWin32\bin b. 如果不知道 Windows 怎么添加环境变量 PATH，百度『Windows 环境变量 PATH』即可 然后你就可以运行 tree 命令了 安装curl 搜索 scoop.sh ，按照官网要求安装(卸载： uninstall scoop) 打开 Windows PowerShell ，粘贴在官网复制的命令行 打开 Git Bash ，输入： which scoop 查看是否已经安装成功 scoop install curl 命令行快捷翻译（fy xxx） npm i -g fanyi echo &quot;alias yd=&#39;fanyi&#39;&quot; &gt;&gt; ~/.bashrc如果提示 commond not found，就需要更新 PATHexport PATH=&quot;xxx:$PATH&quot;其中 xxx 的示例为 /c/Users/lev/AppData/Roaming/npm 命令行常用快捷键 Ctrl + R 搜索历史，再次 Ctrl + R 切换（按左右键，退出选择且并未执行；若直接按回车，退出选择且执行命令行） Ctrl + A 行首 Ctrl + E 行尾 Ctrl + B 退后 Ctrl + F 前进 Ctrl + W 删一个单词 Ctrl + K 删掉这一行（首先要 Ctrl + A 来到行首才能删） Ctrl + C 中断 Ctrl + G 退出搜索 Alt + . 使用上一行命令的最后一个参数 快捷复制粘贴Git Bash 选中即为复制 按鼠标中键粘贴/Shift + insert CMD 选中再回车复制 右键粘贴 软件推荐ConEmu你也可以尝试 cmder， cmder 是基于 ConEmu 上面改的。 Fira Mono For Powerline 一键呼起（本人设置F1） 分屏（本人设置上下分屏： Alt + Shift + D ，左右分屏： Alt + D ，退出分屏：点击某一个分屏，按 Ctrl + D) 剪切板管理软件 ClipboardFusionCtrl + Shift + v 历史复制内容查看 截图软件 Snipaste]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows命令行技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo与GitHub建立博客]]></title>
    <url>%2FTongWenQian%2F2019%2F05%2F31%2FHexo%E4%B8%8EGitHub%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[主要步骤 进入一个安全的目录，比如 cd ~/Desktop 或者 cd ~/Documents，别在根目录 / 建博客。 在 GitHub 上新建一个空 repo，repo 名称是「你的用户名.github.io」（注意个用户名是你的GitHub用户名，不是你的电脑用户名） npm install -g hexo-cli，安装 Hexo hexo init myBlog cd myBlog npm i hexo new 开博大吉，你会看到一个 md 文件的路径 注意：Windows 的路径中的 \ 需要变成 / 才行 运行 start source/_post/开博大吉.md 来编辑这个 md 文件，内容自己想（Ubuntu 系统用 xdg-open xxxxxxxxxxxxxxxxxxx.md 命令） 举例：如果 Windows 提示的是 INFO created: ~\Desktop\myBlog\source_posts\开博大吉.md那么你的命令就应该是 start “~/Desktop/myBlog/source/_posts/开博大吉.md” 注意引号和斜杠，如果路径里没有空格，就不需要引号。 内容示例-–title: 开博大吉-– # 哈哈我的博客开通啦 start _config.yml，编辑网站配置 把第 6 行的 title 改成你想要的名字 把第 9 行的 author 改成你的大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址以 git@github.com: 开头。注意repo:后面有一个空格） npm install hexo-deployer-git --save，安装 git 部署插件 hexo deploy 进入「你的用户名.github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接 用浏览器访问「预览链接/index.html」就应该看到了你的博客！（GitHub Pages 存在延迟，如果没看到，过三分钟再刷新看看） 第二篇博客 hexo new 第二篇博客 复制显示的路径，使用 start 路径 来编辑它 hexo generate hexo deploy 去看你的博客，应该能看到第二篇博客了 换主题 https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集 随便找一个主题，进入主题的 GitHub 首页，比如我找的是 https://github.com/theme-next/hexo-theme-next 复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git cd myBlog git clone https://github.com/theme-next/hexo-theme-next themes/next 将 _config.yml 的第 76 行改为 theme: next，保存 hexo generate hexo deploy 等一分钟，然后刷新你的博客页面，你会看到一个新的外观。如果不喜欢这个主题，就回到第 1 步，重选一个主题。 上传源代码注意「你的用户名.github.io」上保存的只是你的博客，并没有保存「生成博客的程序代码」，你需要再创建一个名为 blog-generator 的空仓库，用来保存 myBlog 里面的「生成博客的程序代码」。 在 GitHub 创建 blog-generator 空仓库 按照截图中的命令执行即可 这样一来，你的博客发布在了「你的用户名.github.io」而你的「生成博客的程序代码」发布在了 blog-generator。所有数据万无一失，你就不会因为误删 myBlog 目录而痛哭了。以后每次 hexo deploy 完之后，博客就会更新；然后你还要要 add / commit /push 一下「生成博客的程序代码」，以防万一。这个 blog-generator 就是用来生成博客的程序，而「你的用户名.github.io」仓库就是你的博客页面。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
